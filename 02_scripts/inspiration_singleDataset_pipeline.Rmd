---
author: "CC"
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
output:
    html_document:
        theme:
            bootswatch: yeti
        toc: yes
        toc_float:
          collapsed: false
          smooth_scroll: true
        number_sections: yes
        df_print: kable
        code_folding: hide
    pdf_document:
        number_sections: yes
        toc: yes
        toc_depth: 3
        keep_tex: no
params:
    analysis.name:
        value: "analysis_"
    new.analysis:
        value: FALSE
    dataset:
        value: NA
        choices: [lab_day_04, lab_day_05, lab_day_05bis, lab_day_06, lab_day_11]
    do.integ:
        value: FALSE
    do.merge:
        value: FALSE
    mito.high:
        value: 10
        min: 1
        max: 100
    ribo.low:
        value: 25
        min: 0
        max: 99
    min.feat:
        value: 200
    min.cells:
        value: 3
    min.counts:
        value: 1500
    max.counts:
        value: 150000
    norm.meth:
        value: "LogNormalize"
    hvg.meth:
        value: mvp
        choices: [vst, mvp, disp]
    hvg.num:
        value: FALSE
    do.scale:
        value: FALSE
    pca.npcs:
        value: 50
    pca.print:
        value: 10
    top.pcs:
        value: 30
    dblt.rate:
        value: 8
    res:
        value: 1.0
    algo.cluster:
        value: 4
        choices: [1, 2, 3, 4]
    top.markers:
        value: 20
    general.seed: 17
title: |
  | Protocole 1:
  | single scRNAseq data analysis
  | `r params$dataset`
---

<!-- Javascript for zooming on figures (adapted from: https://stackoverflow.com/questions/40401680) -->

<!-- Jquery import conflicts with DT::datatable so needs to be commented here -->
<!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script> -->

<style>
.zoomDiv {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  z-index: 50;
  transform: translate(-50%, -50%);
  background-color: #FFFFFF;
  box-shadow: 0px 0px 50px #888888;
  width: fit-content;
  max-width: 90%;
  max-height: 90%;
  overflow: auto;
}

.zoomImg {
  width: 150%;
}
</style>

<script type="text/javascript">
  $(document).ready(function() {
    $('body').prepend("<div class=\"zoomDiv\"><img src=\"\" class=\"zoomImg\"></div>");
    // onClick for all img except the zoomed one and link ones (filter)
    // use 'img.zoom' and out.extra='class=\"zoom\"' in chunk to specify manually which chunk images can be zoomed
    $('img:not(.zoomImg)').filter(':not(a *)').click(function() {
      $('.zoomImg').attr('src', $(this).attr('src'));
      $('.zoomDiv').show();
    })
    // onClick function for hiding div
    $('img.zoomImg').click(function() {
      $('.zoomDiv').hide();
    })
  })
</script>



```{r setup1, eval=TRUE, include=FALSE}
options(knitr.purl.inline = TRUE)
knitr::opts_chunk$set(
  # code evaluation
  eval = TRUE,
  
  # text output
  echo = TRUE,
  results = 'hold',
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  strip.white = TRUE,
  
  # code decoration
  #tidy = TRUE,
  tidy.opts = list(width.cutoff = 90),
  comment = '',
  attr.output='.numberLines',
  
  # plots
  #fig.path = "figure/",      # is set later, in chunk setup2
  fig.show = "asis",         # tuned to "hold" in multiple plots chunk
  dev = c('png', 'pdf'),
  fig.width = 12,
  fig.height = 12,
  #fig.asp=1.3               # fig.height = fig.width * fig.asp
  #out.extra = 'style="border:5px solid orange"'     # orange box arround plots
  fig.align = "center"       # should be tuned to default in multiple plots chunk
)
```

```{r load-lib, include=FALSE}
library(dplyr)
library(Matrix)
library(Seurat)
library(ggplot2)
library(reticulate)
library(scmap)
library(RColorBrewer)
library(DoubletFinder)
library(stringr)
library(kableExtra)
library(formattable)
library(knitr)
library(SingleCellExperiment)
library(BiocGenerics)
library(scales)
library(formatR)
library(uwot)
library(DT)
library(patchwork)
library(ggrepel)
```

```{r get-params, include=FALSE}
bindingIsLocked("params", env = .GlobalEnv)
unlockBinding("params", env = .GlobalEnv)
attach(params)
set.seed(general.seed)
```

```{r sourceCodes}
source("./utilities/extract_topn.R")
source("./utilities/add_dominantMetadata.R")
source("./utilities/additionalPlots.R")
source("./utilities/00_generalDeps.R")
```


# Global settings {.tabset .tabset-pills .tabset-fade}

## `r dataset` analysis settings

```{r show-params}
ul <- unlist(params)
df <- data.frame(keyName=names(ul), value=ul, row.names=NULL)
names(df) <- c('Parameters', 'Values')
df1 <- df[1:ceiling(dim(df)[1]/3),]
df1$Parameters <- cell_spec(df1$Parameters, bold = T)
df2 <- df[(ceiling(dim(df)[1]/3)+1):(2*ceiling(dim(df)[1]/3)),]
df2$Parameters <- cell_spec(df2$Parameters, bold = T)
df3 <- df[((2*ceiling(dim(df)[1]/3))+1):dim(df)[1],]
df3$Parameters <- cell_spec(df3$Parameters, bold = T)


list(df1, df2, df3) %>%
  knitr::kable(align = "ll", row.names = FALSE, escape = F) %>% 
  kable_styling(bootstrap_options = c("striped", "hover"),
                full_width = FALSE)
rm(df)
```


## Directories

Set either input and output directories.

```{r base-path}
#basePath <- "/home/celine/temp2"
#basePath <- "/mnt/DATA_4TB/projects/gastruloids_sc_Lescroart/analysis/seuratAnalysis" # local server
basePath <- "/shared/projects/mothard_in_silico_modeling/seurat_analysis" # IFB server
```

### Input directories

Get the path of the inputs used for the analysis:

- mmgLab.data: directory gathering the data to analyse,

- atlas.folder: directory that contains the Pijuan-Sala et al. atlas,

<!-- - classifier.folder -->

- inputTables.folder: directory that contains table to set the colors,

- otherInputs: directonry that contains the list of the genes of interest.

```{r input-dirs}
inputs.folder <- file.path(basePath, "inputData")

mmgLab.data <- file.path(inputs.folder, "lab_data")
atlas.folder <- file.path(inputs.folder, "atlas")
#classifier.folder <- file.path(inputs.folder, "scmap_pijuansala_classifier")
inputTables.folder <- file.path(inputs.folder, "InputTables")
otherInputs <- file.path(inputs.folder, "other")
```

### Output directories

Create or reuse directories (if already existing) to store the outputs such as
figures, tables and reports.

```{r anteriority, eval=!new.analysis, echo=!new.analysis}
last_analysis <- 0
dirs.in.dir <- list.dirs(basePath, full.names = FALSE, recursive = FALSE)
anterior <- analysis.name %in% dirs.in.dir
if (anterior){
  last_analysis <- max(as.numeric(str_extract_all(anterior, "\\d+", simplify = TRUE)), na.rm=T)
} else {
  params$new.analysis <- TRUE
  attach(params)
}
```

```{r default_analysisName_old, eval=(!new.analysis && analysis.name == "analysis_"), echo=(!new.analysis && analysis.name == "analysis_")}
analysis.name <- paste0(analysis.name, as.character(last_analysis))
```

```{r default_analysisName_new, eval=(new.analysis && analysis.name == "analysis_"), echo=(new.analysis && analysis.name == "analysis_")}
analysis.name <- paste0(analysis.name, as.character(last_analysis + 1))
```

```{r newAnalysis, eval=new.analysis, echo=new.analysis}
baseAnalysis <- file.path(basePath, analysis.name)
if(!dir.exists(baseAnalysis)){dir.create(baseAnalysis)}
rdsObjects <- file.path(baseAnalysis, "rdsObjects")
if(!dir.exists(rdsObjects)){dir.create(rdsObjects)}
print(baseAnalysis)
```

```{r reAnalysis, eval=!new.analysis, echo=!new.analysis}
baseAnalysis <- file.path(basePath, analysis.name)
rdsObjects <- file.path(baseAnalysis, "rdsObjects")
if(!dir.exists(rdsObjects)){dir.create(rdsObjects)}
```

```{r dataset-analysisFolder}
dataset.anFolder <- file.path(baseAnalysis, dataset)
if(!dir.exists(dataset.anFolder)){dir.create(dataset.anFolder)}
fig.folder <- file.path(dataset.anFolder, "figures/")
if(!dir.exists(fig.folder)){dir.create(fig.folder)}
```

```{r setup2, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = TRUE,
  
  # figures
  fig.path = fig.folder
)
```

## Set up color vectors

Load table to in which colors are defined for the labels used in the analysis.

```{r load_colorTables}
colors.table <- read.table(file=file.path(inputTables.folder, "ClusterColors.tsv"), sep="\t", header=T, comment.char="", as.is=T)
colors.celltype <- setNames(colors.table$blind_friendly[!is.na(colors.table$transferred_identity)], colors.table$transferred_identity[!is.na(colors.table$transferred_identity)])
colors.stage <- setNames(c("#bb573b", "#ac9d3e", "#5aaf6a", "#7564b9", "#b94c84", "#ba4b7d", "#90b03d", "#60a756", "#45c097", "#5e8bd5", "#6d71d8", "#573585", "#bd80d5", "#b853a2", "#ba4b7d"), c("Day_04", "Day_05", "Day_06", "Day_07", "Day_10", "Day_11", "E6.5", "E6.75", "E7.0", "E7.25", "E7.5", "E7.75", "E8.0", "E8.25", "E8.5"))
```

```{r starter, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = TRUE,
  echo = TRUE
)
```

# Get `r dataset` data

## Load the data

```{r single-load}
data.path <- file.path(mmgLab.data, dataset)
raw.data <- Read10X(data.dir = data.path, gene = 2)
SO <- CreateSeuratObject(counts=raw.data, project=dataset)
SO
```

## Add and show metadata

```{r add-metaData}
day <- str_to_title(str_extract(dataset, 'day_[0-9]*$'))

SO <- AddMetaData(object = SO, metadata = day, col.name = "day")
SO <- AddMetaData(object = SO, metadata = dataset, col.name = "dataset")
SO <- AddMetaData(SO, metadata = 1, col.name = 'replicate')
SO$model <- "Gastruloids"

data.frame(head(SO@meta.data)) %>%
  knitr::kable(align = "lrrrrrr",
               caption = paste0("6 first lines of the ", dataset, " metadata table")) %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "300px")
```

## Nomenclature for cell names

```{r renaming_cells}
cell_ids <- colnames(SO)
UMIs <- str_extract(cell_ids, '[A-Z]*')
cellnames <- paste(SO$dataset, SO$replicate, UMIs, sep = '_')

SO <- RenameCells(SO, new.names = cellnames)

head(colnames(SO), 4)
```

Below, we can see that there are as many unique cell identifiers as the number of cells.

Number of cells in the dataset: `r dim(SO)[2]`

Number of unique cell identifiers: `r length(unique(colnames(SO)))`


- - -

\clearpage

# Quality control

## Percentage of mitochondrial reads & threshold

```{r addMitoPercentage, fig.align='default', out.width='35%', fig.show='hold'}
SO[["percent.mito"]] <- PercentageFeatureSet(SO, pattern="^mt-")      # CHANGE THE PATTERN TO FIT ANY SPECIES
SO@meta.data[SO@meta.data$percent.mito > mito.high, "outlier.mito"] <- TRUE
SO@meta.data[SO@meta.data$percent.mito < mito.high, "outlier.mito"] <- FALSE

plot1 <- VlnPlot(SO, features = c("percent.mito")) +
    geom_hline(aes(yintercept = mito.high), color = "#FF0000AA", size = 1.5) +
    ggtitle("Mitochondrial expression\npercentage", subtitle = paste0("threshold at ", mito.high, "%")) +
    theme(axis.title.x = element_blank(),
          axis.text = element_text(size = 16),
          axis.text.x = element_text(angle = 0, size = 24, hjust = 0.5, face = "bold"),
          text = element_text(size = 24),
          plot.subtitle = element_text(hjust = 0.5)) +
    NoLegend() +
    scale_y_continuous(labels = scales::percent_format(scale = 1))

plot2 <- VlnPlot(SO, features = c("percent.mito")) +
    geom_hline(aes(yintercept = mito.high), color = "#FF0000AA", size = 1.5) +
    ggtitle("Zoom in", subtitle = paste0("threshold at ", mito.high, "%")) +
    theme(axis.title.x = element_blank(),
          axis.text = element_text(size = 16),
          axis.text.x = element_text(angle = 0, size = 24, hjust = 0.5, face = "bold"),
          text = element_text(size = 24),
          plot.subtitle = element_text(hjust = 0.5)) +
    NoLegend() +
    scale_y_continuous(labels = scales::percent_format(scale = 1)) +
    coord_cartesian(ylim = c(0, 12))

plot1
plot2
```

The number of cells removed by this filter is `r table(SO$outlier.mito)["TRUE"]`.
These cells have a percentage of mitochondrial reads higher than the threshold of `r mito.high`%.


## Percentage of ribosomal reads & threshold

```{r addRiboPercentage, fig.align = "center", out.width='35%'}
SO[["percent.ribo"]] <- PercentageFeatureSet(SO, pattern="^Rp[sl]")   # SEE IF ANY MODIFICATION IS REQUIRED
SO@meta.data[SO@meta.data$percent.ribo > ribo.low, "outlier.ribo"] <- FALSE
SO@meta.data[SO@meta.data$percent.ribo < ribo.low, "outlier.ribo"] <- TRUE

VlnPlot(SO, features = c("percent.ribo")) +
    geom_hline(aes(yintercept = ribo.low), color="#FF0000AA", size=1.5) +
    ggtitle("Ribosomal expression\npercentage", subtitle = paste0("threshold at ", ribo.low, "%")) +
    theme(axis.title.x = element_blank(),
          axis.text = element_text(size = 16),
          axis.text.x = element_text(angle = 0, size = 24, hjust = 0.5, face = "bold"),
          text = element_text(size = 24),
          plot.subtitle = element_text(hjust = 0.5)) +
    NoLegend() +
    scale_y_continuous(labels = scales::percent_format(scale = 1))
```

The number of cells removed by this filter is `r table(SO$outlier.ribo)["TRUE"]`.
These cells have a percentage of ribosomal reads lower than the threshold of `r ribo.low`%.



## UMI counts thresholds

```{r plot-countRNA, fig.align='default', out.width='35%', fig.show='hold'}
SO@meta.data[, "outlier.nCount"] <- FALSE
SO@meta.data[SO@meta.data$nCount_RNA > max.counts | SO@meta.data$nCount_RNA < min.counts, "outlier.nCount"] <- TRUE

plot1 <- VlnPlot(SO, features = c("nCount_RNA")) +
    geom_hline(aes(yintercept = max.counts), color="#FF0000AA", size=1.5) +
    geom_hline(aes(yintercept = min.counts), color="#FF0000AA", size=1.5) +
    ggtitle("UMI counts per cell", subtitle = paste0("thresholds at ", min.counts, " and ", max.counts)) +
    ylab("nCount_RNA") +
    theme(axis.title.x = element_blank(),
          axis.text = element_text(size = 16),
          axis.text.x = element_text(angle = 0, size = 24, hjust = 0.5, face = "bold"),
          text = element_text(size = 24),
          axis.title.y = element_text(size = 16),
          plot.subtitle = element_text(hjust = 0.5)) +
    NoLegend()

plot2 <- plot1 +
    ylim(0, 25000) +
    ggtitle("Zoom in", subtitle = paste0("thresholds at ", min.counts, " and ", max.counts))

plot1
plot2
```

The number of cells removed by this filter is `r table(SO$outlier.nCount)["TRUE"]`.
These cells have either less than `r min.counts` UMI counts or more than `r max.counts` UMI counts.

## Feature counts threshold

```{r plot-featureRNA, out.width='35%'}
SO@meta.data[SO@meta.data$nFeature_RNA > min.feat, "outlier.nFeature"] <- FALSE
SO@meta.data[SO@meta.data$nFeature_RNA < min.feat, "outlier.nFeature"] <- TRUE

VlnPlot(SO, features = c("nFeature_RNA")) +
    geom_hline(aes(yintercept = min.feat), color="#FF0000AA", size=1.5) +
    ggtitle("Number of detected features\nper cell", subtitle = paste0("threshold at ", min.feat, " counts")) +
    ylab("nFeature_RNA") +
    theme(axis.title.x = element_blank(),
          axis.text = element_text(size = 16),
          axis.text.x = element_text(angle = 0, size = 24, hjust = 0.5, face = "bold"),
          text = element_text(size = 24),
          axis.title.y = element_text(size = 16),
          plot.subtitle = element_text(hjust = 0.5)) +
    NoLegend()
```

The number of cells removed by this filter is `r table(SO$outlier.nFeature)["TRUE"]`.
These cells have less than `r min.feat` feature counts.


## Repartition of detected features

Features that are detected in `r min.cells` cells or fewer will be removed from the analysis.
Among the `r dim(SO[1])` features mentioned after loading, some of them were never detected.

```{r plot-geneRepartition}
# Create dataframe
df <- data.frame(rowSums(SO@assays$RNA@counts != 0))
df$features <- rownames(df)
colnames(df) <- c('Nbr_of_cells', 'features')
rownames(df) <- NULL
df_non0 <- df[df$Nbr_of_cells > 0, ]

## Plot gene expression repartition
ggplot(df_non0[c('Nbr_of_cells', 'features')], aes(x = Nbr_of_cells)) +
  geom_histogram(bins = 50) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        text = element_text(size = 20)) +
  ylab('Number of features') +
  xlab('Number of cells') +
  scale_x_continuous(trans = "log10") +
  expand_limits(x=c(0,10500), y=c(0,2000)) +
  geom_vline(aes(xintercept = min.cells), color="green", size=1) +
  ggtitle(paste0("Repartition of detected features\n", dataset)) +
  geom_text(aes(x=min.cells,label = paste0("\n", min.cells), y=1800, hjust = 1.5))
```

The number of features that have never been detected is `r table(df$Nbr_of_cells == 0)["TRUE"]`.
In addition, features that have been detected in `r min.cells` or less will also be removed.
It involves `r table(df_non0$Nbr_of_cells <= min.cells)["TRUE"]`.

In total, `r table(df$Nbr_of_cells <= min.cells)["TRUE"]` features will be removed when the quality control is applied.

## Quality control application

```{r plot-filtering, fig.align='default', out.width='50%', fig.show='hold'}
outliers <- grep("^outlier.", colnames(SO@meta.data), value = TRUE)
qc_param <- c("nCount_RNA", "nFeature_RNA", "percent.mito","percent.ribo")
val <- c("nCount", "nFeature", "mito", "ribo")

plotCols <- list()
for (aValue in val){
  name <- grep(aValue, qc_param, value = TRUE)
  tmp <- grep(aValue, outliers, value = TRUE)
  plotCols[[name]] <- tmp
}

invisible(apply(combn(qc_param, 2), 2, function(x){
  do.call("<-", list(x[1], SO@meta.data[,x[1]]))
  do.call("<-", list(x[2], SO@meta.data[,x[2]]))
    print(
        ggplot(SO@meta.data, # Plot FALSE first and TRUE after
                aes( x = SO@meta.data[,x[1]],
                     y = SO@meta.data[,x[2]],
                    color = SO@meta.data[,plotCols[[x[1]]]] | SO@meta.data[,plotCols[[x[2]]]]
               )) +
          geom_point( size = 0.5) +
          labs( x = x[1], y = x[2], color = "Outliers") +
          scale_color_manual( values = c( "TRUE" = "#FF0000AA", "FALSE" = "#44444444")) +
            theme(legend.key.size = unit(1, 'cm'),
                  legend.background = element_rect(colour = NA, fill = NA),
                  legend.text = element_text(size=10),
                  legend.title = element_text(size=14),
                  legend.position = c(.9,.7),
                  axis.title = element_text(size=16),
                  axis.text = element_text(size = 14)) +
            guides(color = guide_legend(override.aes = list(size = 4))))
}))
```
The number of cells removed by the application of all the filters is `r dim(SO@meta.data[SO@meta.data$percent.mito > mito.high | SO@meta.data$percent.ribo < ribo.low | SO@meta.data$nCount_RNA < min.counts | SO@meta.data$nCount_RNA > max.counts | SO@meta.data$nFeature_RNA < min.feat,])[1]`.


```{r filterQC}
SO <- subset(SO,
             features=which(df$Nbr_of_cells > min.cells),
             subset = percent.mito < mito.high & percent.ribo > ribo.low & nCount_RNA > min.counts & nCount_RNA < max.counts & nFeature_RNA > min.feat)
```

```{r garbage-collec1, include = FALSE}
invisible(gc())
```

```{r save1}
saveRDS(SO, file=file.path(rdsObjects, paste0("01_qualityControl_", dataset, ".rds")))
```

```{r setup3, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = FALSE,
  echo = FALSE
)
```

```{r restart1}
SO <- readRDS(file.path(rdsObjects, paste0("01_qualityControl_", dataset, ".rds")))
```

```{r setup4, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = TRUE,
  echo = TRUE
)
```
- - -

\clearpage


# Doublets identification and removal

Doublets are considered as technical artifacts that have to be filtered out.
To perform the doublets identification and removal, I use the R package DoubletFinder (REFERENCE PAPIER DOUBLET FINDER).  
DoubletFinder relies on 3 main parameters:

-   pN, the number of artificial generated doublets - set by default at 0.25

-   nExp, the number of predicted doublets,

-   pK, the PC neighborhood size used to compute proportion of artificial nearest neighbors (pANN), what will be automatically determined according to the data.

The estimation of predicted doublets (nExp) consists in identifying the heterotypic doublets.
That is to say the data must have a cell identity label. Also, DoubletFinder requires the data to be preprocessed.

## Preprocessing workflow (before doublet removal) {.tabset .tabset-pills .tabset-fade}

<!-- ```{r show-slots, eval=FALSE, echo=FALSE} -->
<!-- data.frame(GetAssayData(SO, slot = "counts")[1:5,1:5]) %>% -->
<!--   knitr::kable(caption = "Raw counts in 'counts' slot") %>%  -->
<!--   kable_styling(bootstrap_options = c("striped", "hover")) %>% -->
<!--   scroll_box(width = "800px", height = "300px") -->
<!-- data.frame(GetAssayData(SO, slot = "data")[1:5,1:5]) %>% -->
<!--   knitr::kable(caption = "Normalized counts in 'data' slot") %>%  -->
<!--   kable_styling(bootstrap_options = c("striped", "hover")) %>% -->
<!--   scroll_box(width = "800px", height = "300px") -->
<!-- ``` -->

```{r hvg-vst1, eval=hvg.meth != "mvp", echo=hvg.meth != "mvp"}
SO <- NormalizeData(SO, normalization.method = norm.meth, verbose=FALSE)
SO <- FindVariableFeatures(SO, nfeatures=hvg.num, selection.method = hvg.meth, verbose=FALSE)
```

```{r hvg-mvp1, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp"}
SO <- NormalizeData(SO, normalization.method = norm.meth, verbose=FALSE)
SO <- FindVariableFeatures(SO, selection.method = hvg.meth, verbose=FALSE)

head(SO@assays[["RNA"]]@meta.features) %>%
  knitr::kable(caption = "Example of HVG selection output") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))

t(as.data.frame(table(SO@assays[["RNA"]]@meta.features$mvp.variable))) %>%
  knitr::kable(caption = "Number of features selected as highly variable genes (HVG)",
               row.names = FALSE,
               escape = F,
               align = "cc") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

```{r preprocess1-1, results='hold', out.width='50%', fig.show='hold', message=TRUE}
SO <- ScaleData(SO, features=rownames(SO), do.scale=TRUE, verbose=FALSE) # do.scale=TRUE to make DoubletFinder working
SO <- RunPCA(SO, npcs = pca.npcs, nfeatures.print = pca.print, seed.use = general.seed, verbose=TRUE)

ElbowPlot(SO, ndims = pca.npcs) +
  theme_minimal() +
  theme(axis.title = element_text(size=14),
  axis.text = element_text(size = 14),
  plot.title = element_text(hjust = 0.5, size = 20)) +
  geom_vline(aes(xintercept = top.pcs), color="#FF0000AA", size=1) +
  ggtitle(paste0(SO@project.name, "\nElbowPlot"))

SO <- RunUMAP(SO, dims = 1:top.pcs, seed.use = general.seed, verbose = FALSE)
resolutions <- c(seq(0.1, 0.4, 0.1), seq(0.6, 1.6, 0.2))
SO <- FindNeighbors(SO, dims = 1:top.pcs, verbose=FALSE)
SO <- FindClusters(SO, resolution = resolutions, algorithm = algo.cluster, random.seed = general.seed, verbose=FALSE)
```

By default, I will use the resolution 1 for the rest of the analysis.

```{r plot-clusters-1, out.width="50%", results='asis'}
invisible(sapply(resolutions, function(ares)
{
    cat("### Res.  ", ares, "\n")
    
    clusterResName <- grep(paste0("RNA_snn_res.", ares, "$"), colnames(SO@meta.data), value = TRUE)
    Idents(SO) <- clusterResName
    
    print(DimPlot(SO,
                   pt.size = 1,
                   label = TRUE,
                   label.size = 6,
                   repel = T) +
               NoLegend() +
               ggtitle(paste0(dataset, " : clusters at resolution ", ares)) +
               theme(plot.title = element_text(hjust = 0.5),
                     axis.text = element_blank(),
                     line = element_blank())
    )
    cat(" \n \n") # Required for '.tabset'
}))
```

## Cells annotation through label transfer from the atlas

In this part, the atlas of Pijuan-Sala et al. is loaded, subsetted to the expected celltypes in our data, and preprocessed.
Then, I perform the label transfer from the atlas to our data, resulting in the following plots.
This cell identity annotation is not the definitive one. Once the doublet are removed, a new annotation will be performed.

```{r mapping-atlas1, out.width="50%"}
# rdsObject generated by the code atlas_harmonyIntegration.R
# the file is considered as an inputs of the atlas
atlas.subset <- readRDS(file.path(atlas.folder, "atlas_preprocessed.rds"))

anchors <- FindTransferAnchors(reference = atlas.subset, query = SO,
                               dims = 1:top.pcs, reference.reduction = "pca")
predictions <- TransferData(anchorset = anchors, refdata = atlas.subset$celltype,
                            dims = 1:top.pcs)
SO <- AddMetaData(SO, metadata = predictions[,"predicted.id"], col.name = "celltype_DF")

# write.table(x = predictions, file = file.path(dataset.anFolder,
#                                                paste0("cellIdent_Predictions_DF_", 
#                                                       dataset, ".csv")), sep = ",", row.names = F, col.names = T)

rm(predictions)
invisible(gc())

Idents(SO) <- SO@meta.data$celltype_DF
DimPlot(SO,
        pt.size = 1,
        repel = TRUE,
        label = TRUE,
        label.size = 6,
        cols = colors.celltype[levels(Idents(SO))]) +
  ggtitle(paste0(dataset, " : cell identities to perform DoubletFinder")) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        line = element_blank()) +
        NoLegend()
```

## Number of heterotypic doublets estimation (nExp parameter)

```{r homotypic-proportion}
annotations <- SO@meta.data$celltype_DF
homotypic.prop <- modelHomotypic(annotations)
nDoublets <- round(ncol(SO)*dblt.rate/100) 
nDoublets_nonhomo <- round(nDoublets*(1-homotypic.prop))
```

Based on the percentage of doublets provided by 10x Genomics, there are `r nDoublets_nonhomo` cells estimated as heterotypic doublets.

## Neighborhood size optimization (pK parameter)

```{r generate-pKs, results='hide', fig.show='hide'}
sweep.res <- paramSweep_v3(SO, PCs = 1:top.pcs) # as estimated from PC elbowPlot
sweep.stats_SO <- summarizeSweep(sweep.res, GT = FALSE)
Sys.sleep(0.5)
bcmvn_SO <- find.pK(sweep.stats_SO)
```

```{r optimize-pK, out.width="50%"}
ggplot(bcmvn_SO, aes(pK, BCmetric, group = 1)) +
  geom_point() +
  geom_line()

pK <- bcmvn_SO %>% # select the pK that corresponds to max bcmvn to optimize doublet detection
  filter(BCmetric == max(BCmetric)) %>%
  select(pK) 
pK <- as.numeric(as.character(pK[[1]]))
```
According to the above plot, the value of the `pK` parameter is set to `r print(pK)`.

## Doublets identification - DoubletFinder run

It is possible to corroborate the identification of doublets with a high number of UMIs.
The plots below allow us to compare these 2 informations.

```{r runDF, results='hide'}
SO <- doubletFinder_v3(SO,
                       PCs = 1:top.pcs,
                       pN = 0.25,
                       pK = pK,
                       nExp = nDoublets_nonhomo)

# Plot the singlets, doublets and the count of UMIs in each cells
col_dblts <- grep("DF.classifications", colnames(SO@meta.data), value=TRUE)
Idents(SO) <- col_dblts

cellsData <- data.frame(SO@reductions[["umap"]]@cell.embeddings, SO@meta.data[,col_dblts])
colnames(cellsData) <- c(colnames(SO@reductions[["umap"]]@cell.embeddings), "col_dblts")
p1 <- ggplot(cellsData[c('UMAP_1', 'UMAP_2')], # Omit the column used for facetting to get all points repeated in all facets
         aes( x = UMAP_1,
              y = UMAP_2)) +
    geom_point( alpha = .4,
                size  = .75,
                color = "grey") +
    geom_point( data = cellsData, # Now provide data including column for facetting
                aes(color = col_dblts),
                alpha = .5,
                size  = 1.2) +
    facet_wrap(facets = vars(factor(col_dblts, levels = c("Singlet", "Doublet"))),
               ncol = 2) +
    NoLegend() +
    theme(plot.title = element_text(hjust = 0.5),
          axis.text = element_blank(),
          line = element_blank())

cellsData <- data.frame(SO@reductions[["umap"]]@cell.embeddings, SO@meta.data$nCount_RNA)
colnames(cellsData) <- c(colnames(SO@reductions[["umap"]]@cell.embeddings), "nCount_RNA")
p2 <- ggplot(cellsData, # Omit the column used for facetting to get all points repeated in all facets
         aes( x = UMAP_1,
              y = UMAP_2)) +
    geom_point(aes(colour = nCount_RNA),
               size  = 1) +
    theme(axis.text = element_blank(),
          line = element_blank())

ylab <- p1$labels$y
p1$labels$y <- p2$labels$y <- ""

xlab <- p1$labels$x
p1$labels$x <- p2$labels$x <- ""

(p1 | p2) +
    plot_layout(widths = c(2,1)) +
    plot_annotation(title = paste0(dataset, " : doublet identification and level of UMI counts"),
                  theme = theme(plot.title = element_text(hjust = 0.5, size = 18)))
grid::grid.draw(grid::textGrob(ylab, x = 0.02, rot = 90))
grid::grid.draw(grid::textGrob(xlab, y = 0.02))
```


```{r df-count-celltypeDF}
# celltypeDF <- as.data.frame(table(Idents(SO), SO@meta.data$celltype_DF))
# head(celltypeDF)
# 
# ggplot(celltypeDF, aes(x = Var2, y=Freq, fill=Var1)) +
#     geom_bar(stat = 'identity') +
#     geom_text(aes(label=Freq), x=1500) +
#     coord_flip()


celltypeMtx <- as.data.frame.matrix(table(Idents(SO), SO@meta.data$celltype_DF))
celltypeMtx %>%
  knitr::kable(caption = "Doublet ratio over celltypes got from Rossi et al. classifier") %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "300px")

clustersRes <- grep(paste0("res.", res, "$"), colnames(SO@meta.data), value=TRUE)
clusterDF <- as.data.frame.matrix(table(Idents(SO), SO@meta.data[,which(colnames(SO@meta.data) == clustersRes)])) 

# ggplot(clusterDF, aes(x = grep(paste0("res.", res, "$"), colnames(SO@meta.data), value=TRUE),
#                       fill = grep("DF.classifications", colnames(SO@meta.data), value=TRUE))) +
#     geom_bar() +
#     theme_classic()

clusterDF %>%
  knitr::kable(caption = paste0("Doublet ratio over clusters at resolution ", res)) %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "300px")

saveRDS(SO, file=file.path(rdsObjects, paste0("02_DFperformed_", dataset, ".rds"))) 
``` 

```{r setup5, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart2}
atlas.subset <- readRDS(file.path(atlas.folder, "atlas_preprocessed.rds"))
SO <- readRDS(file.path(rdsObjects, paste0("02_DFperformed_", dataset, ".rds")))
col_dblts <- grep("DF.classifications", colnames(SO@meta.data), value=TRUE)
Idents(SO) <- SO@meta.data[col_dblts]
```

```{r setup6, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    echo = TRUE
)
```

## Subset to singlets

The number of cells removed by this subsetting is `r table(SO@meta.data[col_dblts])["Doublet"]`.

```{r remove-doublets, results='hide'}
SOsing <- subset(SO, idents='Singlet')

# remove useless columns
SOsing@meta.data[grep("^outlier", colnames(SOsing@meta.data))] <- NULL
SOsing@meta.data[grep("DF.classifications", colnames(SOsing@meta.data))] <- NULL
SOsing@meta.data[grep("pANN", colnames(SOsing@meta.data))] <- NULL
SOsing@meta.data[grep("^RNA_snn_res.", colnames(SOsing@meta.data))] <- NULL
SOsing@meta.data[grep("^seurat_clusters$", colnames(SOsing@meta.data))] <- NULL

rm(SO)
invisible(gc())
```

---

# Preprocessing workflow (after doublets removal) {.tabset .tabset-pills .tabset-fade}

```{r hvg-vst2, eval=hvg.meth != "mvp", echo=hvg.meth != "mvp", message=TRUE}
SOsing <- FindVariableFeatures(SOsing, nfeatures=hvg.num, selection.method = hvg.meth, verbose=FALSE)
var.feats.dataset <- VariableFeatures(SOsing)
saveRDS(var.feats.dataset, file=file.path(rdsObjects, paste0("var.feats.dataset_", dataset, ".rds")))

SOsing <- ScaleData(SOsing, features=rownames(SOsing), do.scale=do.scale, verbose=FALSE)
SOsing <- RunPCA(SOsing, npcs = pca.npcs, nfeatures.print = pca.print, seed.use = general.seed, verbose=TRUE)
```

```{r hvg-mvp2, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp", message=TRUE}
t(as.data.frame(table(SOsing@assays[["RNA"]]@meta.features$mvp.variable))) %>%
  knitr::kable(caption = "Number of features selected as highly variable genes (HVG)",
               row.names = FALSE,
               escape = F,
               align = "cc") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))

var.feats.dataset <- VariableFeatures(SOsing)
saveRDS(var.feats.dataset, file=file.path(rdsObjects, paste0("var.feats.dataset_", dataset, ".rds")))

SOsing <- ScaleData(SOsing, features=rownames(SOsing), do.scale=do.scale, verbose=FALSE)
SOsing <- RunPCA(SOsing, npcs = pca.npcs, nfeatures.print = pca.print, seed.use = general.seed, verbose=TRUE)
```

```{r preprocessSinglet, out.width="50%", results='asis'}
resolutions <- c(seq(0.1, 0.4, 0.1), seq(0.6, 1.6, 0.2))
SOsing <- FindNeighbors(SOsing, dims = 1:top.pcs, verbose=FALSE)
SOsing <- FindClusters(SOsing, resolution = resolutions, algorithm = algo.cluster, random.seed = general.seed, verbose=FALSE)
# SOsing <- RunUMAP(SOsing, dims = 1:top.pcs, seed.use = general.seed, verbose = FALSE)
# 
# invisible(sapply(resolutions, function(ares)
# {
#     cat("## Res.  ", ares, "\n")
#     
#     clusterResName <- grep(paste0("RNA_snn_res.", ares, "$"), colnames(SOsing@meta.data), value = TRUE)
#     Idents(SOsing) <- clusterResName
#     
#     print(DimPlot(SOsing,
#                    pt.size = 1,
#                    label = TRUE,
#                    label.size = 6,
#                    repel = TRUE) +
#                NoLegend() +
#                ggtitle(paste0(dataset, " : clusters at resolution ", ares)) +
#                theme(plot.title = element_text(hjust = 0.5),
#                      axis.text = element_blank(),
#                      line = element_blank())
#     )
# 
#     cat(" \n \n") # Required for '.tabset'
# }))
```

```{r save4}
saveRDS(SOsing, file=file.path(rdsObjects, paste0("03_WF_onSinglets_", dataset, ".rds")))
invisible(gc())
```


```{r setup7, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart3}
SOsing <- readRDS(file.path(rdsObjects, paste0("03_WF_onSinglets_", dataset, ".rds")))
atlas.subset <- readRDS(file.path(atlas.folder, "atlas_preprocessed.rds"))
```

```{r setup8, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    echo = TRUE
)
```

- - -

\clearpage

# Transfer learning from the Atlas

## Cell identity transfer {.tabset .tabset-pills .tabset-fade}

### Dimplot of the predicted celltypes

```{r mapping-atlas2, results='hide', out.width="50%"}
anchors <- FindTransferAnchors(reference = atlas.subset, query = SOsing,
                               dims = 1:top.pcs, reference.reduction = "pca")
predictions <- TransferData(anchorset = anchors, refdata = atlas.subset$celltype,
                            dims = 1:top.pcs)
SOsing <- AddMetaData(SOsing, metadata = predictions[,"predicted.id"], col.name = 'celltype')

write.table(x = predictions, file = file.path(dataset.anFolder,
                                               paste0("cellIdent_Predictions_singleTP_", 
                                                      dataset, ".csv")), sep = ",", row.names = T, col.names = T)

rm(predictions)
invisible(gc())

Idents(SOsing) <- SOsing@meta.data$celltype
DimPlot(SOsing,
        pt.size = 1,
        repel = TRUE,
        label = TRUE,
        label.size = 6,
        cols = colors.celltype[levels(Idents(SOsing))]) +
  ggtitle(paste0(dataset, " : cell identities after doublet removal")) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        line = element_blank()) +
        NoLegend()
```

```{r setup9, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart4}
SOsing <- readRDS(file.path(rdsObjects, paste0("03_WF_onSinglets_", dataset, ".rds")))
atlas.subset <- readRDS(file.path(atlas.folder, "atlas_preprocessed.rds"))
predictions <- read.table(file.path(dataset.anFolder, paste0("cellIdent_Predictions_singleTP_", dataset, ".csv")), sep = ",", header = T)
SOsing <- AddMetaData(SOsing, metadata = predictions[,"predicted.id"], col.name = "celltype")

rm(predictions)
invisible(gc())

Idents(SOsing) <- SOsing@meta.data$celltype
DimPlot(SOsing,
        pt.size = 1,
        repel = TRUE,
        label = TRUE,
        label.size = 6,
        cols = colors.celltype[levels(Idents(SOsing))]) +
  ggtitle(paste0(dataset, " : cell identities after doublet removal")) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        line = element_blank()) +
        NoLegend()
```

```{r setup10, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    echo = TRUE
)
```

### Facets of the predicted celltypes

```{r plot-DF-celltype-facets, fig.height = 20}
cellsData <- data.frame(SOsing@reductions[["umap"]]@cell.embeddings, SOsing@meta.data$celltype)
colnames(cellsData) <- c(colnames(SOsing@reductions[["umap"]]@cell.embeddings), "celltype")

ggplot(cellsData[c('UMAP_1', 'UMAP_2')], # Omit the column used for facetting to get all points repeated in all facets
         aes( x = UMAP_1,
              y = UMAP_2)) +
    geom_point( alpha = .4,
                size  = .75,
                color = "grey") +
    geom_point( data = cellsData, # Now provide data including column for facetting
                aes(color = celltype),
                alpha = .5,
                size  = 1.2) +
    scale_fill_manual(values = colors.celltype[SOsing@meta.data$celltype], aesthetics = "color") +
    facet_wrap(facets = vars(celltype),
               ncol = 3) +
    NoLegend() +
    ggtitle(paste0(dataset, " : cell identity facets")) +
    theme(plot.title = element_text(hjust = 0.5),
          axis.text = element_blank(),
          line = element_blank())
```

### Heatmap of predicted celltypes before vs. after doublets removal
Impact of the doublets removal on the label transfer (Seurat method).

```{r heatmap-afterDF}
Idents(SOsing) <- SOsing@meta.data$day
day <- NULL
transition <- table(SOsing@meta.data[WhichCells(SOsing, idents = day), 'celltype_DF'], SOsing@meta.data[WhichCells(SOsing, idents = day), 'celltype'])
dt <- as.data.frame(transition, row.names = names(SOsing@meta.data[WhichCells(SOsing, idents = day), 'celltype']))
dt[dt == 0] <- NA
names(dt) <- c("beforeDF", "afterDF", "counts")

ggplot(dt, aes(beforeDF, afterDF, fill = counts)) + # nolint
    geom_tile() +
    geom_text(aes(label = counts), color = "black", size = 2.5, fontface = "bold") +
    #scale_color_manual(values = c(NA, "black"), na.value = NA) +
    coord_fixed() +
    scale_fill_gradient(low = "white", high = "pink", na.value="white") +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
    guides(fill = guide_colourbar(barwidth = 0.5,
                                  barheight = 10,
                                  title = "Counts")) +
    ggtitle(paste0(dataset, " : impact of doublets removal on the label transfer")) +
    CenterTitle() +
    labs(x = "Celltype annotation before doublets removal", y = paste0("Celltype annotation after doublets removal"))
```

## Global orientation of the UMAP plots {.tabset .tabset-pills .tabset-fade}

### Integrated data with the atlas {.tabset .tabset-pills .tabset-fade}

```{r integration-with-atlas}
features <- SelectIntegrationFeatures(object.list = list(SOsing, atlas.subset))
anchors <- FindIntegrationAnchors(object.list = list(SOsing, atlas.subset), anchor.features = features)
SO.align <- IntegrateData(anchorset = anchors)

SO.align@project.name <- paste0(dataset, "_with_atlas")
DefaultAssay(SO.align) <- "integrated"

SO.align <- ScaleData(SO.align, assay = DefaultAssay(SO.align), do.scale=do.scale, verbose = FALSE)
SO.align <- RunPCA(SO.align, npcs = pca.npcs, verbose = FALSE)
SO.align <- RunUMAP(SO.align, dims = 1:top.pcs, seed.use = general.seed, verbose = FALSE)
```

#### Facet Atlas versus Gastruloids

```{r facet-atlasVSgast, out.width="50%"}
Idents(SO.align) <- "model"
cellsData <- data.frame(SO.align@reductions[["umap"]]@cell.embeddings, SO.align@meta.data$model)
colnames(cellsData) <- c(colnames(SO.align@reductions[["umap"]]@cell.embeddings), "model")
ggplot(cellsData[c('UMAP_1', 'UMAP_2')], # Omit the column used for facetting to get all points repeated in all facets
         aes( x = UMAP_1,
              y = UMAP_2)) +
    geom_point( alpha = .4,
                size  = 1,
                color = "grey") +
    geom_point( data = cellsData, # Now provide data including column for facetting
                aes(color = model),
                alpha = .5,
                size  = 1.2) +
    facet_wrap(facets = vars(factor(model, levels = c("Embryos", "Gastruloids"))),
               ncol = 2) +
    theme_void() +
    NoLegend() +
    ggtitle(paste0(dataset, " : atlas cells (as Embryos)\n and gastruloids after integration")) +
    theme(plot.title = element_text(hjust = 0.5),
          axis.text = element_blank(),
          line = element_blank())
```

#### Stages in the Atlas dataset

```{r atlasStages-integWithData, out.width="50%"}
Idents(SO.align) <- "day"
cellsData <- data.frame(SO.align@reductions[["umap"]]@cell.embeddings, SO.align@meta.data$day)
colnames(cellsData) <- c(colnames(SO.align@reductions[["umap"]]@cell.embeddings), "day")
ggplot(cellsData[cellsData$day != grep("^Day_", cellsData$day, value = TRUE),], # Omit the column used for facetting to get all points repeated in all facets
         aes( x = UMAP_1,
              y = UMAP_2,
              color = day,
              label = day)) +
    geom_point( alpha = .5,
                size  = 1.2) +
    theme_void() +
    #geom_text_repel() +
    ggtitle(paste0("Atlas stages\n", dataset)) +
    theme(plot.title = element_text(hjust = 0.5),
          axis.text = element_blank(),
          line = element_blank())
```

#### Facet celltypes of the Atlas

```{r facet-atlasCelltypes, fig.height=30}
Idents(SO.align) <- "celltype"
cellsData <- data.frame(SO.align@reductions[["umap"]]@cell.embeddings, SO.align@meta.data$celltype, SO.align@meta.data$model)
colnames(cellsData) <- c(colnames(SO.align@reductions[["umap"]]@cell.embeddings), "celltype", "model")
ggplot(cellsData[cellsData$model == "Embryos", c('UMAP_1', 'UMAP_2')], # Omit the column used for facetting to get all points repeated in all facets
         aes( x = UMAP_1,
              y = UMAP_2)) +
    geom_point( alpha = .4,
                size  = .75,
                color = "grey") +
    geom_point( data = cellsData[cellsData$model == "Embryos",], # Now provide data including column for facetting
                aes(color = celltype),
                alpha = .5,
                size  = 1.2) +
    scale_fill_manual(values = colors.celltype[SO.align@meta.data$celltype], aesthetics = "color") +
    facet_wrap(facets = vars(celltype),
               ncol = 3) +
    theme_void() +
    NoLegend() +
    ggtitle(paste0("Atlas cell identity facets\n", dataset)) +
    theme(plot.title = element_text(hjust = 0.5),
          axis.text = element_blank(),
          line = element_blank())
```


### UMAP of a subset of the atlas

UMAP dimension reduction on atlas, with 200 cells per celltype, 300 neighbors

```{r atlas_refLayout, out.width="50%"}
spread <- 2
min_dist <- 1
Idents(atlas.subset) <- 'celltype'

# Downsample the number of cells per identity class
set.seed(general.seed)
cells.use <- WhichCells(object = atlas.subset, downsample = 200) #colnames(atlas.subset) #sample(colnames(atlas.subset),1000)
nn=300
local_connectivity=1 # Tried 2 and was not so convincing. Should not be more than the local intrinsic dimension of the manifold.
fast_sgd <- F # Should set it to FALSE ultimately, to get exactly reproducible results, but TRUE can be useful as it is faster for early exploration.
umap_init <- "spectral" # "normlaplacian", "spectral" (with noise),  "random", "lvrandom" (Gaussian std 1e-4), "laplacian", or a matrix of initial coordinates.
reduction.use <- "pca"

set.seed(general.seed)
tmp <- umap(X = Embeddings(atlas.subset[[reduction.use]])[cells.use, 1:top.pcs],
            init = umap_init,
            n_neighbors = nn,
            n_components = 3,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            init_sdev = 1e-4,
            local_connectivity = local_connectivity,
            ret_model=T,
            verbose = F)
tmp2 <- 0*Embeddings(atlas.subset[[reduction.use]])[, 1:3]
tmp2[cells.use, ] <- tmp$embedding
atlas.subset[["umap200"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAP200_")

DimPlot(atlas.subset, pt.size = 1, reduction = "umap200", label = TRUE, cells = sample(cells.use),
        repel = TRUE, cols = colors.celltype[levels(Idents(atlas.subset))]) +
  NoLegend() +
  ggtitle(paste0(dataset, " : atlas celltypes\nvisualization reduced to 200 cells per celltype")) +
  CenterTitle() +
  NoAxes()

coordAtlas200 <- as.data.frame(Embeddings(atlas.subset[, cells.use], reduction = "umap200"))
write.table(x = coordAtlas200, file = file.path(dataset.anFolder,
                                               paste0("init_umap200Atlas_", 
                                                      dataset, ".csv")), sep = ",", row.names = TRUE, col.names = TRUE)
```

### Centroid table on atlas celltypes in the subsetted space

```{r atlas_cluster_avg.pos}
Idents(atlas.subset) <- atlas.subset$celltype
x_ref <- data.frame(row.names = unique(atlas.subset$celltype))

for(i in unique(atlas.subset$celltype)){
  x_ref[i,1] <- mean(atlas.subset[["umap200"]]@cell.embeddings[intersect(cells.use,names(atlas.subset$celltype[atlas.subset$celltype==i])),1])
  x_ref[i,2] <- mean(atlas.subset[["umap200"]]@cell.embeddings[intersect(cells.use,names(atlas.subset$celltype[atlas.subset$celltype==i])),2])
  x_ref[i,3] <- mean(atlas.subset[["umap200"]]@cell.embeddings[intersect(cells.use,names(atlas.subset$celltype[atlas.subset$celltype==i])),3])
}

# x_ref$celltype <- rownames(x_ref)
# colnames(x_ref) <- c("umap200_1", "umap200_2", "umap200_3", "celltype")
# ggplot(x_ref, aes(x=umap200_1, y=umap200_2, colour=celltype)) +
#     geom_point(size = 15, alpha=0.7) +
#     scale_color_manual(values = colors.celltype[levels(Idents(atlas.subset))]) +
#     NoLegend() +
#     geom_label_repel(aes(label=celltype),
#                      box.padding   = 0.1)
```

### Create random initial coordinates for the integrated object based on the centroid table

```{r UMAPinit_sharedLayout}
min_dist <- 8
spread <- 25
nn <- 300

# Generate a random position around the layout defined positions for all cells according to their cell types:
noise <- 5
set.seed(general.seed)
x_ini <- data.frame(row.names = colnames(SO.align))
x_ini[,1] <- runif(length(colnames(SO.align)))*noise
x_ini[,2] <- runif(length(colnames(SO.align)))*noise
x_ini[,3] <- runif(length(colnames(SO.align)))*noise
Idents(SO.align) <- SO.align$celltype
for(i in unique(SO.align$celltype)){
  if(i %in% rownames(x_ref)){
    x_ini[WhichCells(SO.align,idents=i),1] <- x_ini[WhichCells(SO.align,idents=i),1]+x_ref[i,1]
    x_ini[WhichCells(SO.align,idents=i),2] <- x_ini[WhichCells(SO.align,idents=i),2]+x_ref[i,2]
    x_ini[WhichCells(SO.align,idents=i),3] <- x_ini[WhichCells(SO.align,idents=i),3]+x_ref[i,3]
  }
}

invisible(gc())
```

### Compute UMAP dimension reduction of the integrated object based on the random initial coordinates

```{r apply_UMAPshared}
cells.use <- colnames(SO.align) #WhichCells(object = tmp,downsample = 300) #colnames(SO) #sample(colnames(SO),1000)
Idents(SO.align) <- SO.align$model
local_connectivity=1 # Should not be more than the local intrinsic dimension of the manifold. I would have imagined 2-3 could be reasonable, but doesn't give good results. 
fast_sgd <- TRUE # Should set it to false ultimately, to get exactly reproducible results, but can use T to get faster for early exploration. 
reduction.use <- "pca"


umap_init <- as.matrix(x_ini[cells.use,]) # "normlaplacian", "spectral" (with noise),  "random", "lvrandom" (Gaussian std 1e-4), "laplacian", or a matrix of initial coordinates. 

set.seed(general.seed)
tmp <- umap(X = Embeddings(SO.align[[reduction.use]])[cells.use, 1:top.pcs],
            init = umap_init,
            n_neighbors = nn,
            n_components = 3,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            init_sdev = 1e-4,
            local_connectivity = local_connectivity,
            ret_model=T,
            verbose = F)
tmp2 <- 0*Embeddings(SO.align[[reduction.use]])[,1:3]
tmp2[cells.use,] <- tmp$embedding
SO.align[["umapShared3d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAPshared3d_", assay = DefaultAssay(SO.align))

coordinates3D <- as.data.frame(Embeddings(SO.align[, WhichCells(SO.align, ident = "Gastruloids")], reduction = "umapShared3d"))
write.table(x = coordinates3D, file = file.path(dataset.anFolder,
                                               paste0("init_umap3Dcoordinates_", 
                                                      dataset, ".csv")), sep = ",", row.names = TRUE, col.names = TRUE)


umap_init <- as.matrix(x_ini[cells.use, 1:2]) # "normlaplacian", "spectral" (with noise),  "random", "lvrandom" (Gaussian std 1e-4), "laplacian", or a matrix of initial coordinates. 

set.seed(general.seed)
tmp <- umap(X = Embeddings(SO.align[[reduction.use]])[cells.use, 1:top.pcs],
            init = umap_init,
            n_neighbors = nn,
            n_components = 2,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            init_sdev = 1e-4,
            local_connectivity = local_connectivity,
            ret_model=T, 
            verbose = F)
tmp2 <- 0 * Embeddings(SO.align[[reduction.use]])[, 1:2]
tmp2[cells.use, ] <- tmp$embedding
SO.align[["umapShared2d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAPshared2d_", assay = DefaultAssay(SO.align))

coordinates2D <- as.data.frame(Embeddings(SO.align[, WhichCells(SO.align, ident = "Gastruloids")], reduction = "umapShared2d"))
write.table(x = coordinates2D, file = file.path(dataset.anFolder,
                                               paste0("init_umap2Dcoordinates_", 
                                                      dataset, ".csv")), sep = ",", row.names = TRUE, col.names = TRUE)

rm(tmp, tmp2, cells.use, x_ref, x_ini)
invisible(gc())
```

# Compute UMAP dimension reduction of the `r dataset` dataset initilized with the coordinates obtained through the atlas integration {.tabset .tabset-pills .tabset-fade}

```{r UMAP-dataset, out.width="50%"}
# Create 3-dimensional UMAP coordinates
init_sdev <- 1e-4
noise_level <- 0
min_dist <- 6
spread <- 15
nn <- 300

umap_init <- as.matrix(coordinates3D)
set.seed(general.seed)
umap_init <- umap_init + cbind(rnorm(nrow(umap_init),sd = noise_level),
                               rnorm(nrow(umap_init),sd = noise_level),
                               rnorm(nrow(umap_init),sd = noise_level))
set.seed(general.seed)
reduction.use <- "pca" # pca1
tmp <- umap(X = Embeddings(SOsing[[reduction.use]])[colnames(SOsing), 1:top.pcs],
            init = umap_init,
            n_neighbors = nn,
            n_components = 3,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            local_connectivity=1,
            ret_model=T,
            verbose = F,
            n_epochs = 1000,
            learning_rate = 1,
            init_sdev = init_sdev)

tmp2 <- 0*Embeddings(SOsing[["pca"]])[,1:3]
tmp2[colnames(SOsing),] <- tmp$embedding
SOsing[["umap3d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAP3d_", assay = DefaultAssay(SOsing))

coordinates3D_final <- as.data.frame(Embeddings(SOsing, reduction = "umap3d"))
write.table(x = coordinates3D_final, file = file.path(dataset.anFolder,
                                               paste0("final_umap3Dcoordinates_", 
                                                      dataset, ".csv")), sep = ",", row.names = TRUE, col.names = TRUE)

# Create 2-dimensional UMAP coordinates
umap_init <- as.matrix(coordinates2D)
set.seed(general.seed)
umap_init <- umap_init + cbind(rnorm(nrow(umap_init),sd = noise_level),
                               rnorm(nrow(umap_init),sd = noise_level))
set.seed(general.seed)
reduction.use <- "pca" # pca1
tmp <- umap(X = Embeddings(SOsing[[reduction.use]])[colnames(SOsing), 1:top.pcs],
            init = umap_init,
            n_neighbors = nn,
            n_components = 2,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            local_connectivity=1,
            ret_model=T,
            verbose = F,
            n_epochs = 1000,
            learning_rate = 1,
            init_sdev = init_sdev)

tmp2 <- 0*Embeddings(SOsing[["pca"]])[,1:2]
tmp2[colnames(SOsing),] <- tmp$embedding
SOsing[["umap2d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAP2d_", assay = DefaultAssay(SOsing))

coordinates2D_final <- as.data.frame(Embeddings(SOsing, reduction = "umap2d"))
write.table(x = coordinates2D_final, file = file.path(dataset.anFolder,
                                               paste0("final_umap2Dcoordinates_", 
                                                      dataset, ".csv")), sep = ",", row.names = TRUE, col.names = TRUE)
```

## Dimplot of the predicted celltypes

```{r, out.width="50%"}
# Plot the celltypes on the umap2d embedding
Idents(SOsing) <- SOsing@meta.data$celltype
DimPlot(SOsing,
        reduction = "umap2d",
        pt.size = 1,
        repel = TRUE,
        label = TRUE,
        label.size = 6,
        cols = colors.celltype[levels(Idents(SOsing))]) +
  ggtitle(paste0(dataset, " : cell identities")) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        line = element_blank()) +
        NoLegend()
```

## Facets of the predicted celltypes

```{r plot-celltype-facets2, fig.height = 20}
cellsData <- data.frame(SOsing@reductions[["umap2d"]]@cell.embeddings, SOsing@meta.data$celltype)
colnames(cellsData) <- c(colnames(SOsing@reductions[["umap2d"]]@cell.embeddings), "celltype")

ggplot(cellsData[c('UMAP2d_1', 'UMAP2d_2')], # Omit the column used for facetting to get all points repeated in all facets
         aes( x = UMAP2d_1,
              y = UMAP2d_2)) +
    geom_point( alpha = .4,
                size  = .75,
                color = "grey") +
    geom_point( data = cellsData, # Now provide data including column for facetting
                aes(color = celltype),
                alpha = .5,
                size  = 1.2) +
    scale_fill_manual(values = colors.celltype[SOsing@meta.data$celltype], aesthetics = "color") +
    facet_wrap(facets = vars(celltype),
               ncol = 3) +
    NoLegend() +
    ggtitle(paste0(dataset, " : cell identity facets")) +
    theme(plot.title = element_text(hjust = 0.5),
          axis.text = element_blank(),
          line = element_blank())
          
rm(umap_init, tmp, tmp2)
invisible(gc())
```

```{r setup13, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = FALSE,
  echo = FALSE
)
```

```{r restart7, results='asis'}
SOsing <- readRDS(file.path(rdsObjects, paste0("07_clusters_", dataset, ".rds")))
resolutions <- c(seq(0.1, 0.4, 0.1), seq(0.6, 1.6, 0.2))
invisible(sapply(resolutions, function(ares)
{
    cat("### Res.  ", ares, "\n")
    
    clusterResName <- grep(paste0("RNA_snn_res.", ares, "$"), colnames(SOsing@meta.data), value = TRUE)
    Idents(SOsing) <- clusterResName
    clustersColor <- setNames(hue_pal()(length(levels(SOsing@meta.data[,clusterResName]))), levels(SOsing@meta.data[,clusterResName]))
    
    print(DimPlot(SOsing,
                   reduction = "umap2d",
                   pt.size = 1,
                   label = TRUE,
                   label.size = 6,
        repel = TRUE,
        cols = clustersColor[levels(Idents(SOsing))]) +
               NoLegend() +
               ggtitle(paste0(dataset, " : clusters at resolution ", ares)) +
               theme(plot.title = element_text(hjust = 0.5),
                     axis.text = element_blank(),
                     line = element_blank())
    )
    cat(" \n \n") # Required for '.tabset'
}))
```

```{r setup16, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = TRUE,
  echo = TRUE
)
```

# Differential expression analysis

```{r selected-resolution}
#SO$seurat_clusters <- NULL
selectedRes <- grep(paste0(DefaultAssay(SOsing), ".*res.", res, "$"), colnames(SOsing@meta.data), value=TRUE)
SOsing$clusters <- SOsing[[selectedRes]]
Idents(SOsing) <- SOsing$clusters

DefaultAssay(SOsing) <- 'RNA'

markers <- FindAllMarkers(SOsing, only.pos = TRUE)
#markers.sign <- markers[markers$p_val_adj < 0.001 & markers$avg_logFC > log(1.5), ]
markers.sign <- markers[order(-markers$avg_log2FC), ]
markers.sign <- markers.sign[order(markers.sign$cluster), ]
markers.sign <- markers.sign[ , c(6, 7, 2:4, 1, 5)]
write.table(x = markers.sign, file = file.path(dataset.anFolder,
                                               paste0("markers_min.pct_logFC_default_", 
                                                      dataset, ".integ.res_", selectedRes, ".csv")), sep = ",", row.names = F, col.names = T)

topNmarkers <- extract_topn(markers.sign, topn = top.markers)

dominantCelltypes <- add_dominantMetadata(SOsing, metadata = "celltype")
topNmarkers <- left_join(topNmarkers, dominantCelltypes, by='cluster')

write.table(x = topNmarkers, file = file.path(dataset.anFolder, paste0("top_", top.markers, "_markers.csv")), sep = ",", row.names = F, col.names = T)

datatable(topNmarkers, rownames = FALSE, filter = "top", options = list(pageLength = 5, scrollX=T))
```

```{r setup17, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = FALSE,
  echo = FALSE
)
```

```{r restart8}
SOsing <- readRDS(file.path(rdsObjects, paste0("07_clusters_", dataset, ".rds")))
selectedRes <- grep(paste0(DefaultAssay(SOsing), ".*res.", res, "$"), colnames(SOsing@meta.data), value=TRUE)
markers.sign <- read.table(file.path(dataset.anFolder, paste0("markers_min.pct_logFC_default_", dataset, ".integ.res_", selectedRes, ".csv")), sep = ",", header = T)
```

```{r setup18, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = TRUE,
  echo = TRUE
)
```

# Additional Plots

```{r addPlots-1}
# Load list of genes of interest
goi <- read.table(file.path(otherInputs, "genes_of_interest3-scRNAseq.tsv"), sep = ",")
goiList <- goi$V1

# Parameters
ntop <- 5


DefaultAssay(SOsing) <- "RNA"
topNmarkers <- extract_topn(markers.sign, topn = ntop)
topNgenes <- unique(topNmarkers$gene)


genesToRemove <- goiList[!(goiList %in% rownames(SOsing))]
if (length(genesToRemove) >= 1){
  cat(paste0("One or more genes of interest are not in the dataset (maybe because of the case):\n\t",
             str_c(genesToRemove, collapse = ", "), "\nThe listed genes are to be removed of the plots"))
}

goiList <- goiList[goiList %in% rownames(SOsing)] # remove the unknown genes
```

## Cluster identity {.tabset .tabset-pills .tabset-fade}

```{r addPlots-3}
Idents(SOsing) <- factor(SOsing@meta.data$RNA_snn_res.1, levels = sort(as.numeric(levels(as.factor(SOsing@meta.data$RNA_snn_res.1)))))
```

### DimPlot of the cluster identity
```{r cluster-dimplot, out.width="50%"}
p <- DimPlot(SOsing, reduction = "umap2d", pt.size = 0.8,
             label = FALSE) +
  ggtitle(paste0("Clusters at resolution 1\n", SOsing@project.name)) +
  CenterTitle() +
  NoAxes()
LabelClusters(p, id = "ident",  fontface = "bold", size = 5)
```

### DotPlot of the markers on cluster identity

```{r cluster-dotPlot-markers}
dotPlotsMarkers(SOsing, topNgenes, title=paste0("Top ", ntop, " markers of each cluster in clusters"))
```

### DotPlot of the genes of interest on cluster identity

```{r cluster-dotPlot-goi}
dotPlotsGoi(SOsing, goiList, title="Genes of interest in clusters")
```

### FeaturePlots of the markers {.tabset .tabset-pills .tabset-fade}

```{r featurePlots-markers, results='asis', out.width='20%', fig.align='default'}
# code with the courtesy of Lionel Spinelli and Romain Fenouil
topMarkers = by( markers.sign, markers.sign[["cluster"]], function(x)
{
  # Filter markers based on adjusted PValue
  x = x[ x[["p_val_adj"]] < 0.005, , drop = FALSE]
  # Sort by decreasing logFC
  x = x[ order(abs(x[["avg_log2FC"]]), decreasing = TRUE), , drop = FALSE ]
  # Return top ones
  return( if(is.null(  top.markers )) head( x, n =  10 ) else head( x, n =  min(top.markers, 10) ))
})

clustersColor <- setNames(hue_pal()(length(names(topMarkers))), names(topMarkers))

invisible( lapply( names( topMarkers), function(clusterName)
{
  cat("#### Cl. <span style='border-radius: 3px border: 3px solid ", clustersColor[clusterName], " padding:0px 2px'>", clusterName, "</span>\n")
  
  # Highlight cells of current cluster on a dimreduc plot
  highlightClusterPlot(clusterName, seuratObject = SOsing, reduction = ifelse( exists("useReduction"), useReduction, "umap2d"))
  
  # Plots expression on projected cells
  invisible( lapply( topMarkers[[clusterName]][["gene"]], function(featureName)
  {
    print( FeaturePlot( SOsing, features = featureName, reduction = ifelse( exists("useReduction"), useReduction, "umap2d"), order = TRUE) +
             theme( axis.title.x = element_blank(),
                    axis.title.y = element_blank(),
                    legend.position = "none"))
  }))
  
  cat(" \n \n") # Required for '.tabset'
}))
```

<!-- ```{r cluster-featurePlot-markers} -->
<!-- ## FeaturePlot the genes of interest -->
<!-- doFeaturePlot(SOsing, topNgenes) -->
<!-- ``` -->

### FeaturePlots of the genes of interest with cluster labels

```{r cluster-featurePlot-goi}
## FeaturePlot the genes of interest
doFeaturePlot(SOsing, goiList)
```

### ViolinPlots of the markers {.tabset .tabset-pills .tabset-fade}

```{r violinPlots-markers, results='asis', out.width='20%', fig.align='default'}
# with courtesy of Lionel Spinelli and Romain Fenouil
invisible( lapply( names( topMarkers), function(clusterName)
{
  cat("#### Cl. <span style='border-radius: 3px border: 3px solid ", clustersColor[clusterName], " padding:0px 2px'>", clusterName, "</span>\n")
  
  # Remind cluster name in an empty figure to keep consistent alignment of panels between tabs
  plot( c( 0, 1), c( 0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n')
  text( x = 0.5, y = 0.5, paste( "Cluster", clusterName), cex = 2, col = clustersColor[clusterName])
  
  # Violinplot for expression value of marker genes by cluster (+ number of 'zero' and 'not zero' cells)
  invisible( lapply( topMarkers[[clusterName]][["gene"]], violinFeatureByCluster, seuratObject = SOsing, clustersColor = clustersColor))
  
  cat(" \n \n") # Required for '.tabset'
}))
```

## Celltype identity {.tabset .tabset-pills .tabset-fade}

```{r addPlots-4}
Idents(SOsing) <- factor(SOsing@meta.data$celltype, levels = sort(levels(as.factor(SOsing@meta.data$celltype))))
```

### DimPlot of the celltype identity {.tabset .tabset-pills .tabset-fade}

```{r celltype-dimplot, results='asis', out.width="50%"}
## DimPlot the celltype
DimPlot(SOsing,
        reduction = "umap2d",
        pt.size = 1,
        repel = TRUE,
        label = TRUE,
        label.size = 6,
        cols = colors.celltype[levels(Idents(SOsing))]) +
  ggtitle(paste0(dataset, " : cell identities")) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        line = element_blank()) +
        NoLegend()

cellsData <- data.frame(SOsing@reductions[["umap2d"]]@cell.embeddings, SOsing@meta.data$celltype)
colnames(cellsData) <- c(colnames(SOsing@reductions[["umap2d"]]@cell.embeddings), "celltype")

invisible(sapply(levels(as.factor(SOsing@meta.data$celltype)), function(act)
{
    cat("#### ", act, "\n")
        
    print(ggplot(cellsData[c('UMAP2d_1', 'UMAP2d_2')], # Omit the column used for facetting to get all points repeated in all facets
         aes( x = UMAP2d_1,
              y = UMAP2d_2)) +
    geom_point( alpha = .4,
                size  = 1,
                color = "grey") +
    geom_point( data = cellsData[cellsData$celltype == act,], # Now provide data including column for facetting
                aes(color = celltype),
                alpha = .5,
                size  = 3.5) +
    theme_void() +
    scale_fill_manual(values = colors.celltype[SOsing@meta.data$celltype], aesthetics = "color") +
    NoLegend() +
    ggtitle(paste0(act)) +
    theme(plot.title = element_text(hjust = 0.5),
          axis.text = element_blank(),
          line = element_blank())
    )

    cat(" \n \n") # Required for '.tabset'
}))
```

### DotPlot of the markers on celltype identity

```{r celltype-dotPlot-markers}
## DotPlot the n-top markers of each celltype
dotPlotsMarkers(SOsing, topNgenes, title=paste0("Top ", ntop, " markers of each cluster in celltypes"))
```

### DotPlot of the genes of interest on celltype identity

```{r celltype-dotPlot-goi}
## DotPlot the genes of interest
dotPlotsGoi(SOsing, goiList, title="Genes of interest in celltypes")
```

